DESIGN PATTERNS:
===============
Design patterns are common solutions and best
practices used to structure code efficiently, making
it more maintainable, reusable, and scalable.

Layout-Component:
=================
Layout components are strategies for organizing and
composing components that manage the layout structure of a
project. These components typically control the positioning
and arrangement of child elements within a page, acting as
containers for other Ul elements or sections.

Container Components:
=====================
Container Components are responsible for loading and managing
data for their child components. This pattern is often used in
conjunction with Presentational Components "Dumb Components"
to keep the Ul more modular and maintainable.

Controlled:
==========
A controlled component is a form element whose value is
controlled by React state. React handles the state of the
component and updates it based on user input through event
handlers (e.g., onChange).

Uncontrolled:
=============
Uncontrolled component is a form element that maintains its own
internal state, and React does not directly manage or track the
value. Instead, we interact with the form element using refs to
access its value when needed.

HOC:Higher-Order Component
===========================
The Higher-Order Component (HOC) design pattern is used to
reuse component logic. It is a function that takes a component as
an argument and returns a new component that enhances the
original one. This pattern allows us to share functionality across
multiple components without repeating code.
HOC **note**:
==============
An HOC does not modify the original component directly,
but instead wraps it in a new component, thereby adding
additional behavior or modifying its props.

Custom Hooks:
=============
Custom hooks are a powerful feature that allows us to
encapsulate and reuse logic across components. They help to
extract component logic into reusable functions, making code
cleaner, more modular, and easier to maintain.
useHookName();
============
Factory:
========
The Factory Design Pattern is a way to create objects without
specifying exactly what kind of object you're creating. It's like having a "factory" that makes objects for us, based on some
conditions or inputs.

Compound Component:
==================
The Compound Component Design Pattern allows for creating
more flexible, reusable, and easy-to-combine components. It
involves splitting a complex component into smaller, individual
subcomponents that can be used together but maintain some
degree of internal control over their behavior.

Compound *note*:
This pattern is useful when you want to create a component that
has multiple subcomponents, but you want to maintain the ability
to customize or control the behavior of each subcomponent from
the parent or container.

Slots:
=====
Slots design pattern allows a component to accept
dynamic content from its parent, and place that content
into specific areas or sections of the component.

The Slots Design Pattern is not a formal or native concept like
some other patterns In React.js, but it draws inspiration from the
way slots work in web components (especially in frameworks like
Vue.js or the Shadow DOM) or from pattern ideas in other Ul
frameworks.

Default slots:
===============
Default slot is known as children property. Whatever you
pass between the opening and closing tag of a component
is passed as children property to that component and acts
as the default slot.

Named slots:
===========
Named slots/props are simply properties that we pass to
a component, each with a specific, descriptive name.
These named props allow the child component to access
and use these values based on the names they are given.

Compound Slots:
================
The slots pattern can be applied to compound
components by defining "named slots" (using props) and
allowing the child components to customize specific areas
of a compound component. This way, each subcomponent
acts like a slot that can be filled with different content.

Render Props:
============
Render Props pattern is used to share code between
components by passing a function as a prop to a
component. The function, which is typically referred to as
the "render prop" returns a React element that gets
rendered. This pattern allows components to be more
flexible and reusable, as the parent component can
control the rendering of content in its child component.


TanStack Query:
================
TanStack Query, previously known as React Query, is a popular
library used in React applications for managing server state and
handling asynchronous data fetching. It provides a set of
hooks that simplify the process of fetching, caching,
synchronizing, and updating data in a React app.

Framework Agnostic:
====================
TanStack Query is not limited to React, it has been expanded to
support other frameworks and libraries, but its most common
use is within React applications.

Query Client:
=============
The Query Client is the core object in TanStack Query that
manages the state and configuration of queries and mutations
in our application. It serves as the primary API for interacting
with the library, enabling us to perform actions like fetching
data, managing cache, and setting global configurations.

Deduplication:
===============
Deduplication means that if we try to fetch the same data
multiple times at once, it will only send one request instead of
many. Deduplication helps avoid asking for the same data over
and over again!

Stale Time:
===========
Stale time refers to the duration during which cached data is
considered fresh. During this period, the data is served from the
cache without triggering a background refetch, which can
improve performance and reduce unnecessary network
requests.


refetchlnterval:
================
refetchlnterval is an option used to automatically refetch data
at a specified interval. It allows us to keep our data fresh
without requiring manual intervention.

useQueries:
===========
useQueries is a hook that allows us to execute multiple queries
in parallel and manage their results in a unified way. This is
useful when you need to fetch data from multiple sources or
endpoints in a single component but want to handle each
queryls state separately.


useMutation:
=============
useMutation is a hook used to handle mutative operations,
operations that create, update, or delete data on a backend or
remote server. Unlike useQuery, which is used for fetching and
caching data, useMutation is specifically designed for actions
that change data.

Race Condition:
================
A race condition happens when multiple asynchronous operations run in parallel, and the results arrive in a different order than expected, potentially causing incorrect or outdated data to be rendered.